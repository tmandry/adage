#include <algorithm>
#include <utility>
#include <cassert>
#include "World.h"
#include "GameBase.h"
#include "world/Wall.h"
#include "nav/NavSystem.h"

World::World(GameBase* game, QString name)
	:	Entity(Pointer<Entity>(), name),
		mGame(game),
		mCellSpace(this),
		mNav()
{
	subclass();
}

World::~World()
{
	if (mNav) delete mNav;
}

void World::removeEntity(QString type, Pointer<Entity> e)
{
	EntityVector& list(mEntities[type]);
	assert(!list.empty());

	mCellSpace.remove(e, e->pos());

	//faster way to remove an element since this is an unordered list
	std::swap(
		*( std::find(list.begin(), list.end(), e) ),
		list.back()
	);
	list.pop_back();
}

Entity::ChildList World::_childEntities() const
{
	//return all immediate children except boundary walls,
	//since they were automatically generated by this class.
	ChildList childs = children();

	foreach(Pointer<Wall> boundary, mBoundaries)
		childs.remove(boundary);

	return childs;
}

void World::setBounds(double left, double top, double right, double bottom)
{
	mLeftBound = left;
	mTopBound = top;
	mRightBound = right;
	mBottomBound = bottom;

	if (!mBoundaries.empty()) for (int i = 0; i < 4; ++i) mBoundaries[i].free();
	mBoundaries.clear();

	//create invisible walls
	mBoundaries.push_back( (new Wall(pointer(), left,top, right,top, false))->pointer() );
	mBoundaries.push_back( (new Wall(pointer(), left,top, left,bottom, false))->pointer() );
	mBoundaries.push_back( (new Wall(pointer(), left,bottom, right,bottom, false))->pointer() );
	mBoundaries.push_back( (new Wall(pointer(), right,bottom, right,top, false))->pointer() );

	mCellSpace.partition();
}

bool World::findPath(NavPath& path, Math::Point start, Math::Point dest)
{
	if (mNav) return mNav->findPath(path, start, dest);
	else return false;
}

void World::setNavSystem(NavSystem* nav)
{
	assert(mNav == 0);
	mNav = nav;
}
